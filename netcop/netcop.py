from detection_method import BackdoorDetector, ONNXModelWrapper
from netcop.read_onnx import *
import onnxruntime as ort
import numpy as np

import torch


class NetCopDetector(BackdoorDetector):
    def __init__(
        self, model_path: str, l_sep: int = None, classifier_after_relu: bool = False, **kwargs
    ):
        super().__init__(model_path, logger=kwargs.pop('logger', None))
        self.model = shape_inference.infer_shapes(self.model)
        self.kwargs = kwargs
        self.log_or_print(f"[*] NetCopDetector extra params: {self.kwargs}")
        if l_sep: self.classifier_after_relu = classifier_after_relu
        self.set_l_sep(l_sep)
    
    def get_params(self):
        return {
            'l_sep': self.l_sep,
            'classifier_after_relu': self.classifier_after_relu,
            'optimizer_epochs': self.kwargs.get('optimizer_epochs', 500),
            'num_IRcs': self.kwargs.get('num_IRcs', 2)
        }
    
    def set_l_sep(self, l_sep: int = None):
        """
        Sets the layer index to split the model into a feature extractor and a classifier.

        Parameters
        ----------
        l_sep : int, optional
            The layer index to split the model. If None, the split layer index is
            automatically determined. Default is None.
        """
        
        if l_sep: self.l_sep = l_sep
        else:
            self.l_sep, self.classifier_after_relu = compute_split_layer_index(self.model)
            self.log_or_print(f"[*] Chosen split layer index: {self.l_sep}{' (after ReLU)' if self.classifier_after_relu else ''}")
        self.classifier = self._get_classifier_part()
        self.optimizer = ONNXModelWrapper(self.classifier, self.classifier_after_relu, logger=self.logger)

        # This line is needed for now because we are using a version of ONNX (V1.17.0) that uses Opset 22,
        # which is still under development and not officially supported by the version of ONNX Runtime
        # we are using (V1.20.1, which is the latest at the time this code was written).
        # ONNX Runtime only guarantees support for models stamped with officially released
        # opset versions, and the current official support for the ai.onnx domain is up to Opset 21.
        # TODO: Remove this line when ONNX Runtime starts supporting Opset 22.

        # self.classifier = version_converter.convert_version(self.classifier, target_version=21)

        # UPDATE: We commented that line because we now set the opset version to 16 as this is the
        # latest version that onnx2torch supports.

        sess_options = ort.SessionOptions()
        # Set the log severity level to 3 (error), so warnings (level 2) are not printed.
        sess_options.log_severity_level = 3
        self.session = ort.InferenceSession(self.classifier.SerializeToString(), sess_options)
    
    def generate_dummy_intermediate_rep(self, target_class, scale_factor = 5e-3):
        """
        Generates a dummy intermediate representation for a given target class using the
        NetCop algorithm. The dummy representation is generated by creating a random
        intermediate representation, and then optimizing it using the optimizer
        to maximize the output of the target class.

        Parameters
        ----------
        target_class : int
            The target class for which to generate the dummy representation.
        scale_factor : float, optional
            The scale factor to use when optimizing the intermediate representation.
            Default is 5e-3.

        Returns
        -------
        optimized_IRc : numpy.ndarray
            The optimized dummy intermediate representation.
        """
        irc = torch.tensor(self._create_random_ir(self._get_intermediate_output_shape()))
        optimized_IRc = self.optimizer.optimize_intermediate_representation(
            irc, target_class, scale_factor,
            num_steps=self.kwargs.get('optimizer_epochs', 500)
        )
        return optimized_IRc.detach().cpu().numpy()
    
    def generate_posteriors_matrix(self, intermediate_representations):
        """
        Generates a posteriors matrix for a given list of intermediate representations.

        Parameters
        ----------
        intermediate_representations : list of numpy.ndarray
            A list of intermediate representations to generate the posteriors matrix for.

        Returns
        -------
        mat_p : numpy.ndarray
            The posteriors matrix, where each row corresponds to a class and each column
            corresponds to an intermediate representation. The entries in the matrix are the
            posteriors of the classes given the intermediate representations.
        """
        mat_p = []
        for representation in intermediate_representations:
            output = None
            for i in representation:
                if output is None:
                    output = self.session.run(None, {self.session.get_inputs()[0].name: i})[0]
                else: output += self.session.run(None, {self.session.get_inputs()[0].name: i})[0]
            output = output / len(representation)
            mat_p.append(output)
        mat_p = np.array(mat_p).transpose()
        return mat_p
    
    def detect(self):
        """
        Detects potential backdoors in the model by generating dummy intermediate representations,
        computing the posteriors matrix, and performing anomaly detection.

        The detection process involves generating intermediate representations for each class,
        averaging them, and using them to compute a posteriors matrix. Anomaly detection is
        performed using the interquartile range (IQR) method on the posteriors to identify potential
        backdoor presence.

        Returns:
            tuple[bool, dict]: A tuple containing a boolean indicating if a backdoor is detected and
            a dictionary with detection metrics including `m_trojaned`, `V`, `lower_bound`, and `upper_bound`.
        """

        # Generate dummy intermediate representations.
        representations = []
        for target_class in self.get_classes():
            IRcs = []
            num_IRcs = self.kwargs.get('num_IRcs', 2)
            for i in range(num_IRcs):
                self.log_or_print(f"[{i+1}/{num_IRcs}]")
                IRcs.append(self.generate_dummy_intermediate_rep(target_class))
            representations.append(IRcs)
        
        # Compute the posteriors matrix.
        self.mat_p = np.squeeze(self.generate_posteriors_matrix(representations))
        np.fill_diagonal(self.mat_p, 0)

        # Posterior Outlier Detection and Anomaly Metric Computation
        self.v = np.mean(self.mat_p, axis=1)
        Q1, Q3 = np.percentile(self.v, 25), np.percentile(self.v, 75)
        IQR = Q3 - Q1
        
        m_trojaned = ((max(self.v) - Q3) / IQR) - 1.5
        lower_bound = (Q1 - 1.5 * IQR)
        upper_bound = (Q3 + 1.5 * IQR)

        is_trojaned = (
            not (lower_bound <= m_trojaned <= upper_bound) or
            any([i < lower_bound or i > upper_bound for i in self.v])
        )

        self.log_or_print(f"Lower Bound: {lower_bound}, Upper Bound: {upper_bound}, m_trojaned: {m_trojaned}")
        self.log_or_print(f"Trojaned: {is_trojaned}")
        return (
            is_trojaned,
            {
                "m_trojaned": float(m_trojaned), "mat_p": self.mat_p.tolist(), "V": self.v.tolist(),
                "lower_bound": float(lower_bound), "upper_bound": float(upper_bound)
            }
        )
    
    def _get_classifier_part(self):
        _, model2 = split_onnx_model(self.model, self.l_sep)
        return model2
    
    def _get_intermediate_output_shape(self):
        graph = self.model.graph

        # Get the output shape of the last node in the first part of the model
        output_tensor = graph.node[self.l_sep - 1].output[0]
        output_info = [v for v in graph.value_info if v.name == output_tensor][0]
        output_shape = [dim.dim_value for dim in output_info.type.tensor_type.shape.dim]

        return output_shape

    def _create_random_ir(self, output_shape):
        # Generate a random tensor with the same shape as the output tensor
        if output_shape[0] == 0: output_shape[0] = 1
        dummy_representation = np.random.rand(*output_shape).astype(np.float32)
        return dummy_representation
