import torch
import torch.nn.functional as F
import torchvision.transforms as transforms
import numpy as np
from torchvision import models
from PIL import Image


def load_model(path):
    # Load checkpoint
    checkpoint = torch.load(path, map_location="cpu", weights_only=False)

    model_name = checkpoint["model_name"]
    num_classes = checkpoint["num_classes"]
    model_weights = checkpoint["model"]

    # Ensure we're using the correct model
    if model_name == "convnext_tiny":
        model = models.convnext_tiny(weights=None)
        model.classifier[2] = torch.nn.Linear(768, num_classes)
    else:
        raise ValueError(f"Unknown model type: {model_name}")

    model.load_state_dict(model_weights)
    model.eval()

    print(f"Model {model_name} loaded successfully!")
    return model


def preprocess_image(image_path):
    """Load and preprocess an image for model input."""
    transform = transforms.Compose([
        transforms.Resize((32, 32)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])
    image = Image.open(image_path).convert("RGB")
    return transform(image).unsqueeze(0)


def compute_adaptive_threshold(clean_images, model, num_perturbations=10, k=1.0):
    """Compute dynamic entropy threshold using clean images."""
    entropy_values = []

    for image in clean_images:
        entropy_scores = []
        for _ in range(num_perturbations):
            noise = torch.rand_like(image) * 0.3
            perturbed_image = image + noise
            perturbed_image = torch.clamp(perturbed_image, 0, 1)

            with torch.no_grad():
                output = model(perturbed_image)
                probs = F.softmax(output, dim=1)
                entropy = -torch.sum(probs * torch.log(probs), dim=1).item()
                entropy_scores.append(entropy)

        entropy_values.append(np.mean(entropy_scores))

    mean_entropy = np.mean(entropy_values)
    std_entropy = np.std(entropy_values)

    threshold = mean_entropy - std_entropy
    print(f"Adaptive Threshold: {threshold:.4f}")

    return threshold


def strip_detection(model, image, threshold, num_perturbations=10):
    """Apply STRIP-based Trojan detection with a dynamic threshold."""
    entropy_scores = []

    for _ in range(num_perturbations):
        noise = torch.rand_like(image) * 0.1
        perturbed_image = image + noise
        perturbed_image = torch.clamp(perturbed_image, 0, 1)

        with torch.no_grad():
            output = model(perturbed_image)
            probs = F.softmax(output, dim=1)
            entropy = -torch.sum(probs * torch.log(probs), dim=1).item()
            entropy_scores.append(entropy)

    avg_entropy = np.mean(entropy_scores)
    print(f"Average entropy: {avg_entropy:.4f}")

    if avg_entropy < threshold:
        print("Warning: Image might be Trojaned!")
    else:
        print("Image appears clean.")


if __name__ == "__main__":
    model = load_model("attack_result.pt")

    clean_image_paths = [
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer1.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer2.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer3.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer4.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer5.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer6.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer7.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer8.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer9.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/deer10.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat1.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat2.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat3.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat4.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat5.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat6.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat7.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat8.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat9.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/cat10.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird1.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird2.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird3.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird4.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird5.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird6.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird7.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird8.png",
        "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird9.png",
    ]

    clean_images = [preprocess_image(img_path) for img_path in clean_image_paths]

    # Compute adaptive threshold
    threshold = compute_adaptive_threshold(clean_images, model)

    # Test a new image
    image_path = "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bd_test_dataset/1/5051.png"
    #image_path = "C:/Users/Nour SalahEldin/Desktop/BackdoorSnitch-main/strip/bird10.png"
    image = preprocess_image(image_path)

    strip_detection(model, image, threshold)
